/*
    Tryton Android
    Copyright (C) 2012 SARL SCOP Scil (contact@scil.coop)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
package org.tryton.client.models;

import java.util.TreeMap;
import java.util.List;
import java.util.Map;
import java.io.IOException;
import java.io.Serializable;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

/** The representation of a view of a given type. It is built in two steps
 * first get the information from the server (arch and so on), then
 * build models which represent the arch in data shape.
 * See TrytonCall for the generation with ArchParser. */
public class ModelView implements Serializable {

    /** Autogenerated serial UID */
    static final long serialVersionUID = -8095612346988475076L;

    // Vital data
    protected int id;
    protected String modelName;
    protected boolean defaultView;
    protected String type;
    protected String arch;
    /** The fields given by the server, indexed by name */
    protected Map<String, Model> fields;
    // Generated data
    protected String title;
    /** The arch in data shape. Accessible only once build is called.
     * It contains fields form the fields map with some extra data. */
    protected List<Model> builtFields;
    // Server optimisation for nested views
    /** Views linked to fields of this view, indexed by field name. */
    protected Map<String, ModelViewTypes> subviews;

    /** Create the view from server data. It must be built to be used
     *  in the application */
    public ModelView(JSONObject json, boolean defaultView)
        throws JSONException {
        // Get general data
        this.id = json.getInt("view_id");
        this.defaultView = defaultView;
        this.arch = json.getString("arch");
        this.type = json.getString("type");
        this.modelName = json.getString("model");
        // Build fields and provided subviews
        this.fields = new TreeMap<String, Model>();
        this.subviews = new TreeMap<String, ModelViewTypes>();
        JSONObject fields = json.getJSONObject("fields");
        JSONArray fieldNames = fields.names();
        for (int i = 0; i < fieldNames.length(); i++) {
            // Fields
            String fieldName = fieldNames.getString(i);
            JSONObject field = fields.getJSONObject(fieldName);
            Model fieldModel = new Model("ir.model.field", field);
            // Subviews
            if (field.has("views")) {
                JSONObject jsSubviews = (JSONObject) field.get("views");
                if (jsSubviews != null && jsSubviews.length() > 0) {
                    JSONArray names = jsSubviews.names();
                    ModelViewTypes mvt = new ModelViewTypes(field.getString("relation"));
                    for (int j = 0; j < names.length(); j++) {
                        String type = names.getString(j);
                        ModelView subview = new ModelView(jsSubviews.getJSONObject(type), false);
                        mvt.putView(type, subview);
                    }
                    this.subviews.put(fieldName, mvt);
                }
            }
            this.fields.put(fieldName, fieldModel);
        }
    }

    public int getId() {
        return this.id;
    }

    public void forceId(int id) {
        this.id = id;
    }

    public String getModelName() {
        return this.modelName;
    }

    public boolean isDefault() {
        return this.defaultView;
    }

    public String getType() {
        return this.type;
    }

    /** Get the view title. Is valid only once the view is built. */
    public String getTitle() {
        return this.title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getArch() {
        return this.arch;
    }

    public Map<String, Model> getFields() {
        return this.fields;
    }

    public Model getField(String name) {
        return this.fields.get(name);
    }

    public List<Model> getStructure() {
        return this.builtFields;
    }

    public ModelViewTypes getSubview(String field) {
        return this.subviews.get(field);
    }
    
    public Map<String, ModelViewTypes> getSubviews() {
        return this.subviews;
    }

    public void setSubviews(String field, ModelViewTypes subviews) {
        this.subviews.put(field, subviews);
    }

    /** Build the structure. It represent arch and fields
     * in a combined way. See ArchParser. */
    public void build(List<Model> structure) {
        this.builtFields = structure;
    }

    @Override
    public boolean equals(Object o) {
        return (o instanceof ModelView
                && ((ModelView)o).modelName.equals(this.modelName)
                && ((ModelView)o).type.equals(this.type)
                && ((ModelView)o).arch.equals(this.arch));
    }

    /** Convert this model to raw bytes to store it */
    public byte[] toByteArray() throws IOException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeInt(this.id);
        oos.writeObject(this.modelName);
        oos.writeBoolean(this.defaultView);
        oos.writeObject(this.type);
        oos.writeObject(this.arch);
        int fieldsCount = this.fields.size();
        oos.writeInt(fieldsCount);
        for (String fieldName : this.fields.keySet()) {
            oos.writeObject(fieldName);
            Model field = this.fields.get(fieldName);
            byte[] fieldData = field.toByteArray();
            oos.writeObject(fieldData);
        }
        byte[] data = bos.toByteArray();
        oos.close();
        return data;
    }

    private ModelView() {}

    @SuppressWarnings("unchecked")
    public static ModelView fromByteArray(byte[] data) throws IOException {
        ByteArrayInputStream bis = new ByteArrayInputStream(data);
        ObjectInputStream ois = new ObjectInputStream(bis);
        ModelView v = new ModelView();
        try {
            v.id = ois.readInt();
            v.modelName = (String) ois.readObject();
            v.defaultView = ois.readBoolean();
            v.type = (String) ois.readObject();
            v.arch = (String) ois.readObject();
            int fieldsCount = ois.readInt();
            v.fields = new TreeMap<String, Model>();
            for (int i = 0; i < fieldsCount; i++) {
                String fieldName = (String) ois.readObject();
                byte[] fieldData = (byte[]) ois.readObject();
                Model field = Model.fromByteArray(fieldData);
                v.fields.put(fieldName, field);
            }
            v.subviews = new TreeMap<String, ModelViewTypes>();
        } catch (ClassNotFoundException e) {
            // Means that the data are wrong.
            v = null;
        }
        ois.close();
        return v;
    }
}